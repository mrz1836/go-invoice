package executor

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"mime"
	"os"
	"path/filepath"
	"strings"
)

// File handling errors
var (
	ErrFileTooLarge    = errors.New("file exceeds maximum size")
	ErrInvalidFileType = errors.New("invalid file type")
	ErrFileNotFound    = errors.New("file not found")
	ErrWorkspaceCreate = errors.New("failed to create workspace")
)

// DefaultFileHandler implements FileHandler with security features.
type DefaultFileHandler struct {
	logger       Logger
	validator    CommandValidator
	sandbox      SandboxConfig
	workspaceDir string
}

// NewDefaultFileHandler creates a new file handler.
func NewDefaultFileHandler(logger Logger, validator CommandValidator, sandbox SandboxConfig) *DefaultFileHandler {
	if logger == nil {
		panic("logger is required")
	}
	if validator == nil {
		panic("validator is required")
	}

	return &DefaultFileHandler{
		logger:    logger,
		validator: validator,
		sandbox:   sandbox,
	}
}

// PrepareWorkspace creates a secure workspace for command execution.
func (f *DefaultFileHandler) PrepareWorkspace(ctx context.Context, files []FileReference) (workDir string, cleanup func(), err error) {
	select {
	case <-ctx.Done():
		return "", nil, ctx.Err()
	default:
	}

	// Create temporary workspace directory
	workDir, err = os.MkdirTemp("", "mcp-workspace-*")
	if err != nil {
		return "", nil, fmt.Errorf("%w: %v", ErrWorkspaceCreate, err)
	}

	// Set restrictive permissions
	if err := os.Chmod(workDir, 0o700); err != nil {
		os.RemoveAll(workDir)
		return "", nil, fmt.Errorf("failed to set workspace permissions: %w", err)
	}

	// Cleanup function
	cleanup = func() {
		if err := os.RemoveAll(workDir); err != nil {
			f.logger.Warn("failed to cleanup workspace",
				"workDir", workDir,
				"error", err,
			)
		}
	}

	// Copy input files to workspace
	for _, file := range files {
		if err := f.copyFileToWorkspace(ctx, file, workDir); err != nil {
			cleanup()
			return "", nil, fmt.Errorf("failed to copy file %s: %w", file.Path, err)
		}
	}

	f.logger.Debug("workspace prepared",
		"workDir", workDir,
		"fileCount", len(files),
	)

	return workDir, cleanup, nil
}

// CollectOutputFiles collects files generated by command execution.
func (f *DefaultFileHandler) CollectOutputFiles(ctx context.Context, workDir string, patterns []string) ([]FileReference, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}

	var files []FileReference

	// If no patterns specified, look for common output files
	if len(patterns) == 0 {
		patterns = []string{
			"*.html",
			"*.pdf",
			"*.json",
			"*.csv",
			"invoice-*.html",
			"report-*.html",
		}
	}

	// Find files matching patterns
	for _, pattern := range patterns {
		matches, err := filepath.Glob(filepath.Join(workDir, pattern))
		if err != nil {
			f.logger.Warn("invalid glob pattern",
				"pattern", pattern,
				"error", err,
			)
			continue
		}

		for _, match := range matches {
			// Skip directories
			info, err := os.Stat(match)
			if err != nil || info.IsDir() {
				continue
			}

			// Create file reference
			ref, err := f.createFileReference(ctx, match, workDir)
			if err != nil {
				f.logger.Warn("failed to create file reference",
					"file", match,
					"error", err,
				)
				continue
			}

			files = append(files, *ref)
		}
	}

	f.logger.Debug("collected output files",
		"workDir", workDir,
		"fileCount", len(files),
	)

	return files, nil
}

// ValidateFile checks if a file is safe to use.
func (f *DefaultFileHandler) ValidateFile(ctx context.Context, path string) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	// Validate path
	if err := f.validator.ValidatePath(ctx, path); err != nil {
		return err
	}

	// Check if file exists
	info, err := os.Stat(path)
	if err != nil {
		if os.IsNotExist(err) {
			return ErrFileNotFound
		}
		return fmt.Errorf("failed to stat file: %w", err)
	}

	// Check if it's a regular file
	if !info.Mode().IsRegular() {
		return fmt.Errorf("not a regular file: %s", path)
	}

	// Check file size
	if info.Size() > f.sandbox.MaxFileSize {
		return fmt.Errorf("%w: %d bytes > %d bytes", ErrFileTooLarge, info.Size(), f.sandbox.MaxFileSize)
	}

	return nil
}

// CreateTempFile creates a temporary file in the secure workspace.
func (f *DefaultFileHandler) CreateTempFile(ctx context.Context, pattern string, content []byte) (string, error) {
	select {
	case <-ctx.Done():
		return "", ctx.Err()
	default:
	}

	// Check content size
	if int64(len(content)) > f.sandbox.MaxFileSize {
		return "", ErrFileTooLarge
	}

	// Create temp file
	tmpFile, err := os.CreateTemp("", pattern)
	if err != nil {
		return "", fmt.Errorf("failed to create temp file: %w", err)
	}
	defer tmpFile.Close()

	// Set restrictive permissions
	if err := tmpFile.Chmod(0o600); err != nil {
		os.Remove(tmpFile.Name())
		return "", fmt.Errorf("failed to set file permissions: %w", err)
	}

	// Write content
	if _, err := tmpFile.Write(content); err != nil {
		os.Remove(tmpFile.Name())
		return "", fmt.Errorf("failed to write content: %w", err)
	}

	f.logger.Debug("created temp file",
		"path", tmpFile.Name(),
		"size", len(content),
	)

	return tmpFile.Name(), nil
}

// copyFileToWorkspace copies a file to the workspace directory.
func (f *DefaultFileHandler) copyFileToWorkspace(ctx context.Context, file FileReference, workDir string) error {
	// Validate source file
	if err := f.ValidateFile(ctx, file.Path); err != nil {
		return err
	}

	// Create destination path
	destPath := filepath.Join(workDir, filepath.Base(file.Path))

	// Open source file
	src, err := os.Open(file.Path)
	if err != nil {
		return fmt.Errorf("failed to open source file: %w", err)
	}
	defer src.Close()

	// Create destination file
	dst, err := os.Create(destPath)
	if err != nil {
		return fmt.Errorf("failed to create destination file: %w", err)
	}
	defer dst.Close()

	// Set restrictive permissions
	if err := dst.Chmod(0o600); err != nil {
		return fmt.Errorf("failed to set file permissions: %w", err)
	}

	// Copy with size limit
	written, err := io.CopyN(dst, src, f.sandbox.MaxFileSize+1)
	if err != nil && err != io.EOF {
		return fmt.Errorf("failed to copy file: %w", err)
	}
	if written > f.sandbox.MaxFileSize {
		return ErrFileTooLarge
	}

	return nil
}

// createFileReference creates a FileReference for a file.
func (f *DefaultFileHandler) createFileReference(ctx context.Context, path string, baseDir string) (*FileReference, error) {
	// Get file info
	info, err := os.Stat(path)
	if err != nil {
		return nil, fmt.Errorf("failed to stat file: %w", err)
	}

	// Calculate relative path
	relPath, err := filepath.Rel(baseDir, path)
	if err != nil {
		relPath = filepath.Base(path)
	}

	// Determine content type
	contentType := mime.TypeByExtension(filepath.Ext(path))
	if contentType == "" {
		contentType = "application/octet-stream"
	}

	// Calculate checksum
	checksum, err := f.calculateChecksum(ctx, path)
	if err != nil {
		f.logger.Warn("failed to calculate checksum",
			"file", path,
			"error", err,
		)
		checksum = ""
	}

	return &FileReference{
		Path:        relPath,
		ContentType: contentType,
		Size:        info.Size(),
		Checksum:    checksum,
		IsTemporary: strings.Contains(baseDir, "mcp-workspace-"),
	}, nil
}

// calculateChecksum calculates SHA256 checksum of a file.
func (f *DefaultFileHandler) calculateChecksum(ctx context.Context, path string) (string, error) {
	file, err := os.Open(path)
	if err != nil {
		return "", err
	}
	defer file.Close()

	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}
