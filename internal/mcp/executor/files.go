package executor

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"
	"io"
	"mime"
	"os"
	"path/filepath"
	"strings"
)

// FileError represents file handling errors.
type FileError struct {
	Op  string
	Msg string
}

func (e *FileError) Error() string {
	return fmt.Sprintf("file operation %s: %s", e.Op, e.Msg)
}

// File handling errors
var (
	ErrFileTooLarge             = &FileError{Op: "validate", Msg: "file exceeds maximum size"}
	ErrInvalidFileType          = &FileError{Op: "validate", Msg: "invalid file type"}
	ErrFileNotFound             = &FileError{Op: "read", Msg: "file not found"}
	ErrWorkspaceCreate          = &FileError{Op: "create", Msg: "failed to create workspace"}
	ErrNotRegularFile           = &FileError{Op: "validate", Msg: "not a regular file"}
	ErrPathOutsideAllowed       = &FileError{Op: "validate", Msg: "file path is outside allowed directories"}
	ErrSrcPathOutsideAllowed    = &FileError{Op: "validate", Msg: "source file path is outside allowed directories"}
	ErrDestPathOutsideWorkspace = &FileError{Op: "validate", Msg: "destination file path is outside of the workspace directory"}
)

// DefaultFileHandler implements FileHandler with security features.
type DefaultFileHandler struct {
	logger    Logger
	validator CommandValidator
	sandbox   SandboxConfig
}

// sanitizePath validates and sanitizes a file path to prevent path traversal attacks.
// It returns a clean, absolute path that has been verified to be within allowed directories.
// This function is designed to satisfy CodeQL's path injection security requirements.
func (f *DefaultFileHandler) sanitizePath(path string, allowedPaths []string) (string, error) {
	// First, clean the path to remove any redundant elements
	cleaned := filepath.Clean(path)

	// Convert to absolute path for consistent validation
	absPath, err := filepath.Abs(cleaned)
	if err != nil {
		return "", fmt.Errorf("invalid path: %w", err)
	}

	// If no allowed paths are specified, return the cleaned absolute path
	if len(allowedPaths) == 0 {
		return absPath, nil
	}

	// Check if the path is within any of the allowed directories
	for _, allowedPath := range allowedPaths {
		absAllowed, err := filepath.Abs(allowedPath)
		if err != nil {
			continue
		}

		// Check if the path is within the allowed directory
		if strings.HasPrefix(absPath, absAllowed+string(os.PathSeparator)) || absPath == absAllowed {
			// Path is validated and safe to use
			return absPath, nil
		}
	}

	// Path is not within any allowed directory
	return "", ErrPathOutsideAllowed
}

// NewDefaultFileHandler creates a new file handler.
func NewDefaultFileHandler(logger Logger, validator CommandValidator, sandbox SandboxConfig) *DefaultFileHandler {
	if logger == nil {
		panic("logger is required")
	}
	if validator == nil {
		panic("validator is required")
	}

	return &DefaultFileHandler{
		logger:    logger,
		validator: validator,
		sandbox:   sandbox,
	}
}

// PrepareWorkspace creates a secure workspace for command execution.
func (f *DefaultFileHandler) PrepareWorkspace(ctx context.Context, files []FileReference) (workDir string, cleanup func(), err error) {
	select {
	case <-ctx.Done():
		return "", nil, ctx.Err()
	default:
	}

	// Create temporary workspace directory
	workDir, err = os.MkdirTemp("", "mcp-workspace-*")
	if err != nil {
		return "", nil, fmt.Errorf("%w: %w", ErrWorkspaceCreate, err)
	}

	// Set restrictive permissions
	if err := os.Chmod(workDir, 0o600); err != nil {
		_ = os.RemoveAll(workDir)
		return "", nil, fmt.Errorf("failed to set workspace permissions: %w", err)
	}

	// Cleanup function
	cleanup = func() {
		if err := os.RemoveAll(workDir); err != nil {
			f.logger.Warn("failed to cleanup workspace",
				"workDir", workDir,
				"error", err,
			)
		}
	}

	// Copy input files to workspace
	for _, file := range files {
		if err := f.copyFileToWorkspace(ctx, file, workDir); err != nil {
			cleanup()
			return "", nil, fmt.Errorf("failed to copy file %s: %w", file.Path, err)
		}
	}

	f.logger.Debug("workspace prepared",
		"workDir", workDir,
		"fileCount", len(files),
	)

	return workDir, cleanup, nil
}

// CollectOutputFiles collects files generated by command execution.
func (f *DefaultFileHandler) CollectOutputFiles(ctx context.Context, workDir string, patterns []string) ([]FileReference, error) {
	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	default:
	}

	var files []FileReference

	// If no patterns specified, look for common output files
	if len(patterns) == 0 {
		patterns = []string{
			"*.html",
			"*.pdf",
			"*.json",
			"*.csv",
			"invoice-*.html",
			"report-*.html",
		}
	}

	// Find files matching patterns
	for _, pattern := range patterns {
		matches, err := filepath.Glob(filepath.Join(workDir, pattern))
		if err != nil {
			f.logger.Warn("invalid glob pattern",
				"pattern", pattern,
				"error", err,
			)
			continue
		}

		for _, match := range matches {
			// Skip directories
			info, err := os.Stat(match)
			if err != nil || info.IsDir() {
				continue
			}

			// Create file reference
			ref, err := f.createFileReference(ctx, match, workDir)
			if err != nil {
				f.logger.Warn("failed to create file reference",
					"file", match,
					"error", err,
				)
				continue
			}

			files = append(files, *ref)
		}
	}

	f.logger.Debug("collected output files",
		"workDir", workDir,
		"fileCount", len(files),
	)

	return files, nil
}

// ValidateFile checks if a file is safe to use.
func (f *DefaultFileHandler) ValidateFile(ctx context.Context, path string) error {
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	// Validate path using the validator
	if err := f.validator.ValidatePath(ctx, path); err != nil {
		return err
	}

	// Sanitize and validate the path using our secure helper function
	// This ensures the path is clean, absolute, and within allowed directories
	sanitizedPath, err := f.sanitizePath(path, f.sandbox.AllowedPaths)
	if err != nil {
		return err
	}

	// SECURITY: Use the sanitized path for all file operations
	// This satisfies CodeQL's requirement for validated paths
	info, err := os.Stat(sanitizedPath)
	if err != nil {
		if os.IsNotExist(err) {
			return ErrFileNotFound
		}
		return fmt.Errorf("failed to stat file: %w", err)
	}

	// Check if it's a regular file
	if !info.Mode().IsRegular() {
		return fmt.Errorf("%w: %s", ErrNotRegularFile, path)
	}

	// Check file size
	if info.Size() > f.sandbox.MaxFileSize {
		return fmt.Errorf("%w: %d bytes > %d bytes", ErrFileTooLarge, info.Size(), f.sandbox.MaxFileSize)
	}

	return nil
}

// CreateTempFile creates a temporary file in the secure workspace.
func (f *DefaultFileHandler) CreateTempFile(ctx context.Context, pattern string, content []byte) (string, error) {
	select {
	case <-ctx.Done():
		return "", ctx.Err()
	default:
	}

	// Check content size
	if int64(len(content)) > f.sandbox.MaxFileSize {
		return "", ErrFileTooLarge
	}

	// Create temp file
	tmpFile, err := os.CreateTemp("", pattern)
	if err != nil {
		return "", fmt.Errorf("failed to create temp file: %w", err)
	}
	defer func() {
		_ = tmpFile.Close()
	}()

	// Set restrictive permissions
	if err := tmpFile.Chmod(0o600); err != nil {
		_ = os.Remove(tmpFile.Name())
		return "", fmt.Errorf("failed to set file permissions: %w", err)
	}

	// Write content
	if _, err := tmpFile.Write(content); err != nil {
		_ = os.Remove(tmpFile.Name())
		return "", fmt.Errorf("failed to write content: %w", err)
	}

	f.logger.Debug("created temp file",
		"path", tmpFile.Name(),
		"size", len(content),
	)

	return tmpFile.Name(), nil
}

// copyFileToWorkspace copies a file to the workspace directory.
func (f *DefaultFileHandler) copyFileToWorkspace(ctx context.Context, file FileReference, workDir string) error {
	// Validate source file
	if err := f.ValidateFile(ctx, file.Path); err != nil {
		return err
	}

	// Create destination path
	destPath := filepath.Join(workDir, filepath.Base(file.Path))

	// Validate destination path
	if err := f.validator.ValidatePath(ctx, destPath); err != nil {
		return fmt.Errorf("invalid destination path: %w", err)
	}

	// SECURITY: Sanitize source path to prevent path traversal
	// This creates a validated, absolute path that is safe to use
	sanitizedSrcPath, err := f.sanitizePath(file.Path, f.sandbox.AllowedPaths)
	if err != nil {
		return fmt.Errorf("source path validation failed: %w", err)
	}

	// SECURITY: Use the sanitized source path for file operations
	// This satisfies CodeQL's requirement for validated paths
	src, err := os.Open(sanitizedSrcPath) // #nosec G304 -- path is sanitized and validated above
	if err != nil {
		return fmt.Errorf("failed to open source file: %w", err)
	}
	defer func() {
		_ = src.Close()
	}()

	// SECURITY: Sanitize destination path within workspace
	// First ensure the workspace directory is absolute and clean
	absWorkDir, err := filepath.Abs(workDir)
	if err != nil {
		return fmt.Errorf("failed to resolve workspace directory: %w", err)
	}

	// Clean and validate the destination path
	cleanDestPath := filepath.Clean(destPath)
	absDestPath, err := filepath.Abs(cleanDestPath)
	if err != nil {
		return fmt.Errorf("failed to resolve destination file path: %w", err)
	}

	// Verify destination is within workspace
	if !strings.HasPrefix(absDestPath, absWorkDir+string(os.PathSeparator)) && absDestPath != absWorkDir {
		return ErrDestPathOutsideWorkspace
	}

	// SECURITY: Use the validated absolute destination path
	// This path has been verified to be within the workspace directory
	sanitizedDestPath := absDestPath

	dst, err := os.Create(sanitizedDestPath) // #nosec G304 -- path is sanitized and validated above
	if err != nil {
		return fmt.Errorf("failed to create destination file: %w", err)
	}
	defer func() {
		_ = dst.Close()
	}()

	// Set restrictive permissions
	if chmodErr := dst.Chmod(0o600); chmodErr != nil {
		return fmt.Errorf("failed to set file permissions: %w", chmodErr)
	}

	// Copy with size limit
	written, err := io.CopyN(dst, src, f.sandbox.MaxFileSize+1)
	if err != nil && !errors.Is(err, io.EOF) {
		return fmt.Errorf("failed to copy file: %w", err)
	}
	if written > f.sandbox.MaxFileSize {
		return ErrFileTooLarge
	}

	return nil
}

// createFileReference creates a FileReference for a file.
func (f *DefaultFileHandler) createFileReference(ctx context.Context, path string, baseDir string) (*FileReference, error) {
	// Get file info
	info, err := os.Stat(path)
	if err != nil {
		return nil, fmt.Errorf("failed to stat file: %w", err)
	}

	// Calculate relative path
	relPath, err := filepath.Rel(baseDir, path)
	if err != nil {
		relPath = filepath.Base(path)
	}

	// Determine content type
	contentType := mime.TypeByExtension(filepath.Ext(path))
	if contentType == "" {
		contentType = "application/octet-stream"
	}

	// Calculate checksum
	checksum, err := f.calculateChecksum(ctx, path)
	if err != nil {
		f.logger.Warn("failed to calculate checksum",
			"file", path,
			"error", err,
		)
		checksum = ""
	}

	return &FileReference{
		Path:        relPath,
		ContentType: contentType,
		Size:        info.Size(),
		Checksum:    checksum,
		IsTemporary: strings.Contains(baseDir, "mcp-workspace-"),
	}, nil
}

// calculateChecksum calculates SHA256 checksum of a file.
func (f *DefaultFileHandler) calculateChecksum(_ context.Context, path string) (string, error) {
	// Clean the path to prevent traversal
	cleanPath := filepath.Clean(path)
	file, err := os.Open(cleanPath)
	if err != nil {
		return "", err
	}
	defer func() {
		_ = file.Close()
	}()

	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}

	return hex.EncodeToString(hash.Sum(nil)), nil
}
